# Pality: High-Performance Java Method Replacement

Pality is a powerful Java library that allows you to replace Java method implementations with native machine code, significantly improving performance for simple methods.

## Overview

Inspired by JDK's `@IntrisincCandidate` optimization, Pality provides similar functionality without modifying the JDK itself. By using the `@Replace` annotation, you can seamlessly substitute your Java method implementations with optimized machine code.

## Features

- Replace Java methods with native machine code
- Support for multiple implementations based on architecture and operating system
- Easy integration with existing Java projects
- Significant performance improvements for simple methods

## Usage

### Basic Method Replacement

```java
@Replace("48 89 D1 4C 89 C2 8D 04 11 C3")
private static int sum(int a, int b) {
    System.out.println("This message will be replaced by native code!");
    return a + b;
}
```

To activate the replacement:

```java
MethodReplacer.register(MainClass.class);
```

### Multiple Implementations

You can provide different implementations for various architectures and operating systems:

```java
@Replace(value = "your code for Windows", arch = Architecture.AMD64, os = OperatingSystem.WINDOWS)
@Replace(value = "your code for Linux", arch = Architecture.AMD64, os = OperatingSystem.UNIX_LIKE)
@Replace(value = "your code for any other systems")
private static int sum(int a, int b) {
    System.out.println("This message will be replaced by native code!");
    return a + b;
}
```

## Generating Machine Code

To obtain the machine code for your replacements, you can write your functions in a language like Zig and then convert them to assembly. Here's an example:

1. Write your function in Zig:

```zig
export fn sum2(a: i32, b: i32) i32 {
    return a + b;
}

export fn sum6(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32) i32 {
    return a + b + c + d + e + f;
}
```

2. Convert to assembly:

```asm
sum2:
    lea eax, [rcx + rdx]
    ret

sum6:
    add ecx, edx
    lea eax, [r8 + r9]
    add eax, ecx
    add eax, dword [rsp + 40]
    add eax, dword [rsp + 48]
    ret
```

### Understanding Calling Conventions

To properly implement your machine code, it's crucial to understand the calling conventions used by Java. You can find information about these conventions in the following classes:

- For AMD64: `AMD64HotSpotRegisterConfig` class in the `jdk.vm.ci.hotspot.amd64` package
- For AArch64: `AArch64HotSpotRegisterConfig` class in the `jdk.vm.ci.hotspot.aarch64` package

```java
if (windowsOS) {
    javaGeneralParameterRegisters = new RegisterArray(rdx, r8, r9, rdi, rsi, rcx);
    nativeGeneralParameterRegisters = new RegisterArray(rcx, rdx, r8, r9);
} else {
    javaGeneralParameterRegisters = new RegisterArray(rsi, rdx, rcx, r8, r9, rdi);
    nativeGeneralParameterRegisters = new RegisterArray(rdi, rsi, rdx, rcx, r8, r9);
}
```

> The Java calling convention is a «shifted» version of the C ABI. By skipping the first C ABI register we can call non-static jni methods with small numbers of arguments without having to shuffle the arguments at all. Since we control the java ABI we ought to at least get some advantage out of it.

For static methods, adjust your assembly code accordingly. For example:

```asm
sum2:
    lea eax, [rdx + r8]
    ret
```

### Working with the Stack

When dealing with methods that have more than four arguments, you'll need to work with the stack. Here's an example of how to modify the sum6 function to work with Java's calling convention, while mostly preserving the assembly code generated by Zig:

```asm
    mov rcx, rdx        ; Move 1st Java arg (rdx) to 1st native arg (rcx)
    mov rdx, r8         ; Move 2nd Java arg (r8) to 2nd native arg (rdx)
    mov r8, r9          ; Move 3rd Java arg (r9) to 3rd native arg (r8)
    mov r9, rdi         ; Move 4th Java arg (rdi) to 4th native arg (r9)
    
    ; Set up stack frame
    push rbp
    sub rsp, 0x20

    add ecx, edx
    lea eax, [r8 + r9]
    add eax, ecx
    add eax, dword [rsp + 0x40]  ; Access 5th argument
    add eax, dword [rsp + 0x48]  ; Access 6th argument
    
    ; Clean up stack frame
    add rsp, 0x20
    pop rbp
    
    ret
```

Note that we've mostly preserved the assembly code generated by Zig, only adding the necessary adjustments to align with Java's calling convention and handle the stack properly.

After creating your assembly code, generate a binary file using NASM and view it with a hex editor to obtain the machine code for the `@Replace` annotation.

## Running the Tool

Pality consists of two subprojects: `api` and `runtime`. Here are some ways to run your application with Pality:

1. Using command-line arguments:

```
java -cp api.jar;runtime.jar;test.jar --add-exports jdk.internal.vm.ci/jdk.vm.ci.services=ALL-UNNAMED --add-exports jdk.internal.vm.ci/jdk.vm.ci.runtime=ALL-UNNAMED --add-exports jdk.internal.vm.ci/jdk.vm.ci.meta=ALL-UNNAMED --add-exports jdk.internal.vm.ci/jdk.vm.ci.code=ALL-UNNAMED --add-exports jdk.internal.vm.ci/jdk.vm.ci.hotspot=ALL-UNNAMED -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI MainClass
```

2. Using Java Agent:

```
java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -cp api.jar;test.jar -javaagent:runtime.jar MainClass
```

3. Using module path:

```
java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -cp test.jar --module-path api.jar --upgrade-module-path runtime.jar MainClass
```

You can also provide a list of classes to the Java Agent:

```
-javaagent:runtime.jar=io.pality.test.MainClass
```

## Supported Platforms

- Architectures: AMD64 and AArch64
- Operating Systems: Windows, Linux, macOS (Windows and Unix-like systems)

## Requirements

- JVMCI must be enabled to run the program

## License

The `api` subproject is licensed under the MIT License.
The `runtime` subproject follows JVMCI license requirements.

## Support

You can support this project by giving it a star on GitHub!